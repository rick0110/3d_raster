import json
import math
import os
import subprocess
import sys
from dataclasses import dataclass, asdict, field
from typing import Dict, List, Optional, Tuple

from PySide6 import QtCore, QtGui, QtWidgets


# -----------------------------
# Data model
# -----------------------------


def _clamp01(x: float) -> float:
    return max(0.0, min(1.0, float(x)))


@dataclass
class Vec3:
    x: float = 0.0
    y: float = 0.0
    z: float = 0.0


@dataclass
class Color3:
    r: float = 1.0
    g: float = 1.0
    b: float = 1.0


@dataclass
class Transform:
    translate: Vec3 = field(default_factory=Vec3)
    scale: Vec3 = field(default_factory=lambda: Vec3(1.0, 1.0, 1.0))
    rot_z_deg: float = 0.0


@dataclass
class MaterialSpec:
    kind: str = "matte"  # matte | checker | mirror
    params: Dict[str, float] = field(default_factory=dict)


@dataclass
class ObjectSpec:
    name: str
    kind: str  # ball | cube | planeuv | cilinder
    params: Dict[str, float] = field(default_factory=dict)
    transform: Transform = field(default_factory=Transform)
    material: MaterialSpec = field(default_factory=MaterialSpec)


@dataclass
class CameraSpec:
    eye: Vec3 = field(default_factory=lambda: Vec3(12, 12, 4))
    look_at: Vec3 = field(default_factory=lambda: Vec3(0, 0, 2.5))
    up: Vec3 = field(default_factory=lambda: Vec3(0, 0, 1))
    fov: float = 45.0
    img_width: int = 200
    img_height: int = 200


@dataclass
class LightSpec:
    kind: str = "area"  # area only in this app
    position: Vec3 = field(default_factory=lambda: Vec3(10, 5, 15))
    look_at: Vec3 = field(default_factory=lambda: Vec3(0, 0, 0))
    up: Vec3 = field(default_factory=lambda: Vec3(1, 1, 1))
    width: float = 4.0
    height: float = 4.0
    color: Color3 = field(default_factory=lambda: Color3(0.8, 0.6, 0.6))
    intensity: float = 1.7


@dataclass
class SceneSpec:
    name: str = "Editor Scene"
    background: Color3 = field(default_factory=lambda: Color3(0.7, 0.8, 0.95))
    ambient_light: Color3 = field(default_factory=lambda: Color3(0.1, 0.1, 0.1))
    max_depth: int = 4
    camera: CameraSpec = field(default_factory=CameraSpec)
    light: LightSpec = field(default_factory=LightSpec)
    objects: List[ObjectSpec] = field(default_factory=list)


# -----------------------------
# Exporter (.py scene)
# -----------------------------


def _py_vec3(v: Vec3) -> str:
    return f"Vector3D({v.x:.6g}, {v.y:.6g}, {v.z:.6g})"


def _py_color(c: Color3) -> str:
    return f"Color({c.r:.6g}, {c.g:.6g}, {c.b:.6g})"


def _rot_z_matrix(theta_deg: float) -> List[List[float]]:
    t = math.radians(theta_deg)
    c = math.cos(t)
    s = math.sin(t)
    return [[c, -s, 0.0], [s, c, 0.0], [0.0, 0.0, 1.0]]


def _scale_matrix(s: Vec3) -> List[List[float]]:
    return [[s.x, 0.0, 0.0], [0.0, s.y, 0.0], [0.0, 0.0, s.z]]


def _matmul3(a: List[List[float]], b: List[List[float]]) -> List[List[float]]:
    out = [[0.0, 0.0, 0.0] for _ in range(3)]
    for i in range(3):
        for j in range(3):
            out[i][j] = sum(a[i][k] * b[k][j] for k in range(3))
    return out


def export_scene_py(scene: SceneSpec, out_path: str) -> None:
    module_name = os.path.splitext(os.path.basename(out_path))[0]

    lines: List[str] = []
    lines.append(
        "\n".join(
            [
                '"""Auto-generated by app.py scene editor.',
                "",
                "Do not edit by hand unless you know what you're doing.",
                f"Module name: {module_name}",
                '"""',
            ]
        )
    )
    lines.append("import math")
    lines.append("import numpy as np")
    lines.append("from src.base import BaseScene, Color")
    lines.append("from src.vector3d import Vector3D")
    lines.append("from src.camera import Camera")
    lines.append("from src.light import AreaLight")
    lines.append(
        "from src.shapes import Ball, Cube, PlaneUV, ObjectTransform, Translate, Cilinder"
    )
    lines.append(
        "from src.materials import SimpleMaterialWithShadows, CheckerboardMaterial, ReflectiveMaterial"
    )
    lines.append("")

    lines.append("def _m(m):")
    lines.append("    return np.array(m, dtype=float)")
    lines.append("")

    lines.append("class Scene(BaseScene):")
    lines.append("    def __init__(self):")
    lines.append(f"        super().__init__({scene.name!r})")
    lines.append(f"        self.background = {_py_color(scene.background)}")
    lines.append(f"        self.ambient_light = {_py_color(scene.ambient_light)}")
    lines.append(f"        self.max_depth = {int(scene.max_depth)}")

    cam = scene.camera
    lines.append(
        "        self.camera = Camera(\n"
        f"            eye={_py_vec3(cam.eye)},\n"
        f"            look_at={_py_vec3(cam.look_at)},\n"
        f"            up={_py_vec3(cam.up)},\n"
        f"            fov={float(cam.fov):.6g},\n"
        f"            img_width={int(cam.img_width)},\n"
        f"            img_height={int(cam.img_height)},\n"
        "        )"
    )

    li = scene.light
    lines.append("        self.lights = [AreaLight(")
    lines.append(f"            position={_py_vec3(li.position)},")
    lines.append(f"            look_at={_py_vec3(li.look_at)},")
    lines.append(f"            up={_py_vec3(li.up)},")
    lines.append(f"            width={float(li.width):.6g},")
    lines.append(f"            height={float(li.height):.6g},")
    lines.append(f"            color={_py_color(li.color)},")
    lines.append(f"            intensity={float(li.intensity):.6g}))")
    lines.append("")

    for obj in scene.objects:
        # materials (per-object, simple + deterministic)
        mat = obj.material
        if mat.kind == "matte":
            kd = float(mat.params.get("diffuse", 0.9))
            ka = float(mat.params.get("ambient", 0.12))
            ks = float(mat.params.get("specular", 0.15))
            shin = float(mat.params.get("shininess", 32.0))
            dr = float(mat.params.get("dr", 0.7))
            dg = float(mat.params.get("dg", 0.2))
            db = float(mat.params.get("db", 0.2))
            lines.append(
                f"        _mat_{obj.name} = SimpleMaterialWithShadows({ka:.6g}, {kd:.6g}, Color({dr:.6g}, {dg:.6g}, {db:.6g}), {ks:.6g}, Color(1,1,1), {shin:.6g})"
            )
        elif mat.kind == "checker":
            ka = float(mat.params.get("ambient", 1.0))
            kd = float(mat.params.get("diffuse", 0.9))
            sq = float(mat.params.get("square_size", 1.0))
            lines.append(
                f"        _mat_{obj.name} = CheckerboardMaterial({ka:.6g}, {kd:.6g}, {sq:.6g})"
            )
        else:  # mirror
            rc = float(mat.params.get("reflection", 1.0))
            lines.append(
                f"        _mat_{obj.name} = ReflectiveMaterial(0.0, 0.0, Color(0,0,0), 0.0, Color(0,0,0), reflection_coefficient={rc:.6g})"
            )

        # shapes
        if obj.kind == "ball":
            radius = float(obj.params.get("radius", 1.0))
            lines.append(f"        _shape_{obj.name} = Ball(center=Vector3D(0,0,0), radius={radius:.6g})")
        elif obj.kind == "cube":
            size = float(obj.params.get("size", 1.0))
            lines.append(f"        _shape_{obj.name} = Cube(size={size:.6g})")
        elif obj.kind == "cilinder":
            radius = float(obj.params.get("radius", 0.5))
            height = float(obj.params.get("height", 2.0))
            lines.append(f"        _shape_{obj.name} = Cilinder(radius={radius:.6g}, height={height:.6g})")
        else:  # planeuv
            px = float(obj.params.get("px", 0.0))
            py = float(obj.params.get("py", 0.0))
            pz = float(obj.params.get("pz", 0.0))
            nx = float(obj.params.get("nx", 0.0))
            ny = float(obj.params.get("ny", 0.0))
            nz = float(obj.params.get("nz", 1.0))
            fx = float(obj.params.get("fx", 1.0))
            fy = float(obj.params.get("fy", 0.0))
            fz = float(obj.params.get("fz", 0.0))
            lines.append(
                "        _shape_%s = PlaneUV(point=Vector3D(%.6g, %.6g, %.6g), normal=Vector3D(%.6g, %.6g, %.6g), forward_direction=Vector3D(%.6g, %.6g, %.6g))"
                % (obj.name, px, py, pz, nx, ny, nz, fx, fy, fz)
            )

        # transforms: for PlaneUV, keep as-is (more predictable)
        if obj.kind != "planeuv":
            t = obj.transform
            # build linear matrix = Rz @ S
            # (consistent with your existing scenes: rot_z(...) @ scale3(...))
            s = t.scale
            # avoid singular matrices
            sx, sy, sz = float(s.x), float(s.y), float(s.z)
            if abs(sx) < 1e-8:
                sx = 1e-3
            if abs(sy) < 1e-8:
                sy = 1e-3
            if abs(sz) < 1e-8:
                sz = 1e-3

            R = _rot_z_matrix(float(t.rot_z_deg))
            S = _scale_matrix(Vec3(sx, sy, sz))
            M = _matmul3(R, S)
            lines.append(f"        _shape_{obj.name} = ObjectTransform(_shape_{obj.name}, _m({M}))")

            tr = t.translate
            if abs(tr.x) > 1e-12 or abs(tr.y) > 1e-12 or abs(tr.z) > 1e-12:
                lines.append(
                    f"        _shape_{obj.name} = Translate(_shape_{obj.name}, Vector3D({tr.x:.6g}, {tr.y:.6g}, {tr.z:.6g}))"
                )

        lines.append(f"        self.add(_shape_{obj.name}, _mat_{obj.name})")
        lines.append("")

    content = "\n".join(lines) + "\n"
    with open(out_path, "w", encoding="utf-8") as f:
        f.write(content)


# -----------------------------
# GUI widgets helpers
# -----------------------------


class FloatEdit(QtWidgets.QDoubleSpinBox):
    def __init__(self, minimum=-1e9, maximum=1e9, step=0.1, decimals=4, parent=None):
        super().__init__(parent)
        self.setRange(minimum, maximum)
        self.setSingleStep(step)
        self.setDecimals(decimals)


class IntEdit(QtWidgets.QSpinBox):
    def __init__(self, minimum=1, maximum=100000, step=1, parent=None):
        super().__init__(parent)
        self.setRange(minimum, maximum)
        self.setSingleStep(step)


def _row(label: str, widget: QtWidgets.QWidget) -> QtWidgets.QWidget:
    w = QtWidgets.QWidget()
    lay = QtWidgets.QHBoxLayout(w)
    lay.setContentsMargins(0, 0, 0, 0)
    lab = QtWidgets.QLabel(label)
    lab.setMinimumWidth(90)
    lay.addWidget(lab)
    lay.addWidget(widget, 1)
    return w


def _vec3_editor(prefix: str) -> Tuple[QtWidgets.QWidget, FloatEdit, FloatEdit, FloatEdit]:
    box = QtWidgets.QGroupBox(prefix)
    lay = QtWidgets.QHBoxLayout(box)
    x = FloatEdit(step=0.25)
    y = FloatEdit(step=0.25)
    z = FloatEdit(step=0.25)
    lay.addWidget(QtWidgets.QLabel("x"))
    lay.addWidget(x)
    lay.addWidget(QtWidgets.QLabel("y"))
    lay.addWidget(y)
    lay.addWidget(QtWidgets.QLabel("z"))
    lay.addWidget(z)
    return box, x, y, z


def _color_editor(prefix: str) -> Tuple[QtWidgets.QWidget, FloatEdit, FloatEdit, FloatEdit]:
    box = QtWidgets.QGroupBox(prefix)
    lay = QtWidgets.QHBoxLayout(box)
    r = FloatEdit(minimum=0.0, maximum=1.0, step=0.05, decimals=3)
    g = FloatEdit(minimum=0.0, maximum=1.0, step=0.05, decimals=3)
    b = FloatEdit(minimum=0.0, maximum=1.0, step=0.05, decimals=3)
    lay.addWidget(QtWidgets.QLabel("r"))
    lay.addWidget(r)
    lay.addWidget(QtWidgets.QLabel("g"))
    lay.addWidget(g)
    lay.addWidget(QtWidgets.QLabel("b"))
    lay.addWidget(b)
    return box, r, g, b


# -----------------------------
# Main Window
# -----------------------------


class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Raytracer Scene Editor")

        self.scene = SceneSpec()
        self._selected_index: Optional[int] = None

        self._default_scene()
        self._build_ui()
        self._refresh_object_list()
        self._select_object(0 if self.scene.objects else None)

    def _default_scene(self):
        # ground plane
        plane = ObjectSpec(
            name="ground",
            kind="planeuv",
            params={"px": 0, "py": 0, "pz": 0, "nx": 0, "ny": 0, "nz": 1, "fx": 1, "fy": 0, "fz": 0},
            material=MaterialSpec(kind="checker", params={"square_size": 1.0}),
        )
        # a ball
        ball = ObjectSpec(
            name="ball1",
            kind="ball",
            params={"radius": 0.8},
            transform=Transform(translate=Vec3(-2.5, 0.0, 0.8)),
            material=MaterialSpec(kind="matte", params={"dr": 0.2, "dg": 0.85, "db": 0.2}),
        )
        # a cube
        cube = ObjectSpec(
            name="cube1",
            kind="cube",
            params={"size": 1.0},
            transform=Transform(translate=Vec3(2.0, 0.0, 1.0), scale=Vec3(1.5, 1.5, 1.5), rot_z_deg=30),
            material=MaterialSpec(kind="mirror", params={"reflection": 0.8}),
        )
        self.scene.objects = [plane, ball, cube]

    def _build_ui(self):
        central = QtWidgets.QWidget()
        self.setCentralWidget(central)
        root = QtWidgets.QHBoxLayout(central)

        # Left: Scene settings
        scene_panel = QtWidgets.QWidget()
        scene_lay = QtWidgets.QVBoxLayout(scene_panel)
        scene_lay.setContentsMargins(0, 0, 0, 0)

        self.scene_name = QtWidgets.QLineEdit(self.scene.name)
        scene_lay.addWidget(_row("Nome", self.scene_name))

        bg_box, self.bg_r, self.bg_g, self.bg_b = _color_editor("Background")
        amb_box, self.amb_r, self.amb_g, self.amb_b = _color_editor("Ambient")
        scene_lay.addWidget(bg_box)
        scene_lay.addWidget(amb_box)

        self.max_depth = IntEdit(minimum=0, maximum=50)
        self.max_depth.setValue(self.scene.max_depth)
        scene_lay.addWidget(_row("Max depth", self.max_depth))

        cam_box = QtWidgets.QGroupBox("Camera")
        cam_lay = QtWidgets.QVBoxLayout(cam_box)
        self.cam_eye_box, self.cam_eye_x, self.cam_eye_y, self.cam_eye_z = _vec3_editor("Eye")
        self.cam_look_box, self.cam_look_x, self.cam_look_y, self.cam_look_z = _vec3_editor("LookAt")
        self.cam_up_box, self.cam_up_x, self.cam_up_y, self.cam_up_z = _vec3_editor("Up")
        cam_lay.addWidget(self.cam_eye_box)
        cam_lay.addWidget(self.cam_look_box)
        cam_lay.addWidget(self.cam_up_box)
        self.cam_fov = FloatEdit(minimum=1, maximum=179, step=1, decimals=1)
        self.cam_fov.setValue(self.scene.camera.fov)
        cam_lay.addWidget(_row("FOV", self.cam_fov))
        self.img_w = IntEdit(minimum=16, maximum=4096)
        self.img_h = IntEdit(minimum=16, maximum=4096)
        self.img_w.setValue(self.scene.camera.img_width)
        self.img_h.setValue(self.scene.camera.img_height)
        cam_lay.addWidget(_row("Width", self.img_w))
        cam_lay.addWidget(_row("Height", self.img_h))
        scene_lay.addWidget(cam_box)

        light_box = QtWidgets.QGroupBox("Light (Area)")
        light_lay = QtWidgets.QVBoxLayout(light_box)
        self.light_pos_box, self.light_px, self.light_py, self.light_pz = _vec3_editor("Position")
        self.light_look_box, self.light_lx, self.light_ly, self.light_lz = _vec3_editor("LookAt")
        self.light_up_box, self.light_ux, self.light_uy, self.light_uz = _vec3_editor("Up")
        light_lay.addWidget(self.light_pos_box)
        light_lay.addWidget(self.light_look_box)
        light_lay.addWidget(self.light_up_box)
        self.light_w = FloatEdit(minimum=0.01, maximum=1e6, step=0.25)
        self.light_h = FloatEdit(minimum=0.01, maximum=1e6, step=0.25)
        self.light_int = FloatEdit(minimum=0.0, maximum=1e6, step=0.1)
        self.light_w.setValue(self.scene.light.width)
        self.light_h.setValue(self.scene.light.height)
        self.light_int.setValue(self.scene.light.intensity)
        light_lay.addWidget(_row("Width", self.light_w))
        light_lay.addWidget(_row("Height", self.light_h))
        light_lay.addWidget(_row("Intensity", self.light_int))
        lc_box, self.light_r, self.light_g, self.light_b = _color_editor("Color")
        light_lay.addWidget(lc_box)
        scene_lay.addWidget(light_box)

        scene_lay.addStretch(1)

        # Center: object list + actions
        list_panel = QtWidgets.QWidget()
        list_lay = QtWidgets.QVBoxLayout(list_panel)
        list_lay.setContentsMargins(0, 0, 0, 0)

        self.object_list = QtWidgets.QListWidget()
        self.object_list.currentRowChanged.connect(self._select_object)
        list_lay.addWidget(QtWidgets.QLabel("Objects"))
        list_lay.addWidget(self.object_list, 1)

        btn_row = QtWidgets.QHBoxLayout()
        self.btn_add = QtWidgets.QPushButton("Add")
        self.btn_del = QtWidgets.QPushButton("Delete")
        btn_row.addWidget(self.btn_add)
        btn_row.addWidget(self.btn_del)
        list_lay.addLayout(btn_row)

        self.btn_add.clicked.connect(self._add_object)
        self.btn_del.clicked.connect(self._delete_object)

        # Right: object editor + render preview
        right_panel = QtWidgets.QWidget()
        right_lay = QtWidgets.QVBoxLayout(right_panel)
        right_lay.setContentsMargins(0, 0, 0, 0)

        self.obj_group = QtWidgets.QGroupBox("Selected Object")
        obj_lay = QtWidgets.QVBoxLayout(self.obj_group)

        self.obj_name = QtWidgets.QLineEdit()
        obj_lay.addWidget(_row("Name", self.obj_name))

        self.obj_kind = QtWidgets.QComboBox()
        self.obj_kind.addItems(["ball", "cube", "cilinder", "planeuv"])
        obj_lay.addWidget(_row("Type", self.obj_kind))

        # type params stack
        self.params_stack = QtWidgets.QStackedWidget()
        self._params_pages = {}
        self._params_pages["ball"] = self._build_ball_page()
        self._params_pages["cube"] = self._build_cube_page()
        self._params_pages["cilinder"] = self._build_cilinder_page()
        self._params_pages["planeuv"] = self._build_plane_page()
        for k in ["ball", "cube", "cilinder", "planeuv"]:
            self.params_stack.addWidget(self._params_pages[k])
        obj_lay.addWidget(self.params_stack)

        # transform
        self.tr_group = QtWidgets.QGroupBox("Transform")
        tr_lay = QtWidgets.QVBoxLayout(self.tr_group)
        self.tr_t_box, self.tr_tx, self.tr_ty, self.tr_tz = _vec3_editor("Translate")
        self.tr_s_box, self.tr_sx, self.tr_sy, self.tr_sz = _vec3_editor("Scale")
        tr_lay.addWidget(self.tr_t_box)
        tr_lay.addWidget(self.tr_s_box)
        self.tr_rz = FloatEdit(minimum=-360, maximum=360, step=5, decimals=1)
        tr_lay.addWidget(_row("RotZ (deg)", self.tr_rz))
        obj_lay.addWidget(self.tr_group)

        # material
        self.mat_group = QtWidgets.QGroupBox("Material")
        mat_lay = QtWidgets.QVBoxLayout(self.mat_group)
        self.mat_kind = QtWidgets.QComboBox()
        self.mat_kind.addItems(["matte", "checker", "mirror"])
        mat_lay.addWidget(_row("Kind", self.mat_kind))

        self.mat_stack = QtWidgets.QStackedWidget()
        self.mat_matte = self._build_matte_page()
        self.mat_checker = self._build_checker_page()
        self.mat_mirror = self._build_mirror_page()
        self.mat_stack.addWidget(self.mat_matte)
        self.mat_stack.addWidget(self.mat_checker)
        self.mat_stack.addWidget(self.mat_mirror)
        mat_lay.addWidget(self.mat_stack)
        obj_lay.addWidget(self.mat_group)

        right_lay.addWidget(self.obj_group, 0)

        # Export/render
        export_group = QtWidgets.QGroupBox("Export / Render")
        exp_lay = QtWidgets.QVBoxLayout(export_group)
        self.out_scene_path = QtWidgets.QLineEdit("scene_editor_output.py")
        self.btn_browse_scene = QtWidgets.QPushButton("Browse")
        row = QtWidgets.QHBoxLayout()
        row.addWidget(self.out_scene_path, 1)
        row.addWidget(self.btn_browse_scene)
        exp_lay.addWidget(QtWidgets.QLabel("Scene file (.py)") )
        exp_lay.addLayout(row)

        self.samples = IntEdit(minimum=1, maximum=4096)
        self.samples.setValue(16)
        self.jobs = IntEdit(minimum=1, maximum=64)
        self.jobs.setValue(4)
        exp_lay.addWidget(_row("Samples", self.samples))
        exp_lay.addWidget(_row("Jobs", self.jobs))

        self.out_img_path = QtWidgets.QLineEdit("preview.png")
        exp_lay.addWidget(QtWidgets.QLabel("Output image") )
        exp_lay.addWidget(self.out_img_path)

        self.btn_export = QtWidgets.QPushButton("Export Scene")
        self.btn_render = QtWidgets.QPushButton("Render")
        exp_btns = QtWidgets.QHBoxLayout()
        exp_btns.addWidget(self.btn_export)
        exp_btns.addWidget(self.btn_render)
        exp_lay.addLayout(exp_btns)

        self.render_log = QtWidgets.QPlainTextEdit()
        self.render_log.setReadOnly(True)
        self.render_log.setMaximumBlockCount(5000)
        exp_lay.addWidget(self.render_log, 1)

        self.preview = QtWidgets.QLabel()
        self.preview.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.preview.setMinimumSize(300, 300)
        self.preview.setScaledContents(True)
        exp_lay.addWidget(self.preview, 2)

        right_lay.addWidget(export_group, 1)

        root.addWidget(scene_panel, 1)
        root.addWidget(list_panel, 0)
        root.addWidget(right_panel, 2)

        # bind events
        self.btn_browse_scene.clicked.connect(self._browse_scene_path)
        self.btn_export.clicked.connect(self._export_scene_clicked)
        self.btn_render.clicked.connect(self._render_clicked)

        self.obj_name.editingFinished.connect(self._apply_obj_edits)
        self.obj_kind.currentTextChanged.connect(self._obj_kind_changed)
        self.mat_kind.currentTextChanged.connect(self._mat_kind_changed)

        for w in [
            self.tr_tx,
            self.tr_ty,
            self.tr_tz,
            self.tr_sx,
            self.tr_sy,
            self.tr_sz,
            self.tr_rz,
        ]:
            w.valueChanged.connect(self._apply_obj_edits)

        # scene binds
        self.scene_name.editingFinished.connect(self._apply_scene_edits)
        self.max_depth.valueChanged.connect(self._apply_scene_edits)
        self.cam_fov.valueChanged.connect(self._apply_scene_edits)
        self.img_w.valueChanged.connect(self._apply_scene_edits)
        self.img_h.valueChanged.connect(self._apply_scene_edits)

        for w in [self.bg_r, self.bg_g, self.bg_b, self.amb_r, self.amb_g, self.amb_b]:
            w.valueChanged.connect(self._apply_scene_edits)

        for w in [
            self.cam_eye_x,
            self.cam_eye_y,
            self.cam_eye_z,
            self.cam_look_x,
            self.cam_look_y,
            self.cam_look_z,
            self.cam_up_x,
            self.cam_up_y,
            self.cam_up_z,
        ]:
            w.valueChanged.connect(self._apply_scene_edits)

        for w in [
            self.light_px,
            self.light_py,
            self.light_pz,
            self.light_lx,
            self.light_ly,
            self.light_lz,
            self.light_ux,
            self.light_uy,
            self.light_uz,
            self.light_w,
            self.light_h,
            self.light_int,
            self.light_r,
            self.light_g,
            self.light_b,
        ]:
            w.valueChanged.connect(self._apply_scene_edits)

        # defaults for scene widgets
        self._load_scene_widgets()

    def _build_ball_page(self) -> QtWidgets.QWidget:
        w = QtWidgets.QWidget()
        lay = QtWidgets.QVBoxLayout(w)
        self.ball_radius = FloatEdit(minimum=0.001, maximum=1e6, step=0.1)
        lay.addWidget(_row("Radius", self.ball_radius))
        self.ball_radius.valueChanged.connect(self._apply_obj_edits)
        lay.addStretch(1)
        return w

    def _build_cube_page(self) -> QtWidgets.QWidget:
        w = QtWidgets.QWidget()
        lay = QtWidgets.QVBoxLayout(w)
        self.cube_size = FloatEdit(minimum=0.001, maximum=1e6, step=0.1)
        lay.addWidget(_row("Size", self.cube_size))
        self.cube_size.valueChanged.connect(self._apply_obj_edits)
        lay.addStretch(1)
        return w

    def _build_cilinder_page(self) -> QtWidgets.QWidget:
        w = QtWidgets.QWidget()
        lay = QtWidgets.QVBoxLayout(w)
        self.cyl_radius = FloatEdit(minimum=0.001, maximum=1e6, step=0.1)
        self.cyl_height = FloatEdit(minimum=0.001, maximum=1e6, step=0.1)
        lay.addWidget(_row("Radius", self.cyl_radius))
        lay.addWidget(_row("Height", self.cyl_height))
        self.cyl_radius.valueChanged.connect(self._apply_obj_edits)
        self.cyl_height.valueChanged.connect(self._apply_obj_edits)
        lay.addStretch(1)
        return w

    def _build_plane_page(self) -> QtWidgets.QWidget:
        w = QtWidgets.QWidget()
        lay = QtWidgets.QVBoxLayout(w)
        self.pl_point_box, self.pl_px, self.pl_py, self.pl_pz = _vec3_editor("Point")
        self.pl_norm_box, self.pl_nx, self.pl_ny, self.pl_nz = _vec3_editor("Normal")
        self.pl_fwd_box, self.pl_fx, self.pl_fy, self.pl_fz = _vec3_editor("Forward")
        lay.addWidget(self.pl_point_box)
        lay.addWidget(self.pl_norm_box)
        lay.addWidget(self.pl_fwd_box)
        for wdg in [
            self.pl_px,
            self.pl_py,
            self.pl_pz,
            self.pl_nx,
            self.pl_ny,
            self.pl_nz,
            self.pl_fx,
            self.pl_fy,
            self.pl_fz,
        ]:
            wdg.valueChanged.connect(self._apply_obj_edits)
        lay.addStretch(1)
        return w

    def _build_matte_page(self) -> QtWidgets.QWidget:
        w = QtWidgets.QWidget()
        lay = QtWidgets.QVBoxLayout(w)
        self.matte_dr = FloatEdit(minimum=0.0, maximum=1.0, step=0.05, decimals=3)
        self.matte_dg = FloatEdit(minimum=0.0, maximum=1.0, step=0.05, decimals=3)
        self.matte_db = FloatEdit(minimum=0.0, maximum=1.0, step=0.05, decimals=3)
        lay.addWidget(_row("Color R", self.matte_dr))
        lay.addWidget(_row("Color G", self.matte_dg))
        lay.addWidget(_row("Color B", self.matte_db))
        self.matte_dr.valueChanged.connect(self._apply_obj_edits)
        self.matte_dg.valueChanged.connect(self._apply_obj_edits)
        self.matte_db.valueChanged.connect(self._apply_obj_edits)
        lay.addStretch(1)
        return w

    def _build_checker_page(self) -> QtWidgets.QWidget:
        w = QtWidgets.QWidget()
        lay = QtWidgets.QVBoxLayout(w)
        self.checker_square = FloatEdit(minimum=0.001, maximum=1e6, step=0.25)
        lay.addWidget(_row("Square size", self.checker_square))
        self.checker_square.valueChanged.connect(self._apply_obj_edits)
        lay.addStretch(1)
        return w

    def _build_mirror_page(self) -> QtWidgets.QWidget:
        w = QtWidgets.QWidget()
        lay = QtWidgets.QVBoxLayout(w)
        self.mirror_reflect = FloatEdit(minimum=0.0, maximum=1.0, step=0.05, decimals=3)
        lay.addWidget(_row("Reflection", self.mirror_reflect))
        self.mirror_reflect.valueChanged.connect(self._apply_obj_edits)
        lay.addStretch(1)
        return w

    # ----- selection / list -----

    def _refresh_object_list(self):
        self.object_list.blockSignals(True)
        self.object_list.clear()
        for obj in self.scene.objects:
            self.object_list.addItem(f"{obj.name} ({obj.kind})")
        self.object_list.blockSignals(False)

    def _select_object(self, index: Optional[int]):
        if index is None or index < 0 or index >= len(self.scene.objects):
            self._selected_index = None
            self.obj_group.setEnabled(False)
            return
        self._selected_index = index
        self.obj_group.setEnabled(True)
        self._load_object_widgets(self.scene.objects[index])

    # ----- add / delete -----

    def _add_object(self):
        kind, ok = QtWidgets.QInputDialog.getItem(
            self,
            "Add Object",
            "Type:",
            ["ball", "cube", "cilinder", "planeuv"],
            0,
            False,
        )
        if not ok:
            return

        base_name = kind
        existing = {o.name for o in self.scene.objects}
        i = 1
        name = f"{base_name}{i}"
        while name in existing:
            i += 1
            name = f"{base_name}{i}"

        if kind == "ball":
            obj = ObjectSpec(name=name, kind=kind, params={"radius": 1.0})
        elif kind == "cube":
            obj = ObjectSpec(name=name, kind=kind, params={"size": 1.0})
        elif kind == "cilinder":
            obj = ObjectSpec(name=name, kind=kind, params={"radius": 0.5, "height": 2.0})
        else:
            obj = ObjectSpec(
                name=name,
                kind=kind,
                params={"px": 0, "py": 0, "pz": 0, "nx": 0, "ny": 0, "nz": 1, "fx": 1, "fy": 0, "fz": 0},
                material=MaterialSpec(kind="checker", params={"square_size": 1.0}),
            )

        self.scene.objects.append(obj)
        self._refresh_object_list()
        self.object_list.setCurrentRow(len(self.scene.objects) - 1)

    def _delete_object(self):
        if self._selected_index is None:
            return
        del self.scene.objects[self._selected_index]
        self._refresh_object_list()
        new_idx = min(self._selected_index, len(self.scene.objects) - 1)
        self.object_list.setCurrentRow(new_idx)

    # ----- widget load/apply -----

    def _load_scene_widgets(self):
        self.scene_name.setText(self.scene.name)

        self.bg_r.setValue(_clamp01(self.scene.background.r))
        self.bg_g.setValue(_clamp01(self.scene.background.g))
        self.bg_b.setValue(_clamp01(self.scene.background.b))

        self.amb_r.setValue(_clamp01(self.scene.ambient_light.r))
        self.amb_g.setValue(_clamp01(self.scene.ambient_light.g))
        self.amb_b.setValue(_clamp01(self.scene.ambient_light.b))

        self.max_depth.setValue(int(self.scene.max_depth))

        cam = self.scene.camera
        self.cam_eye_x.setValue(cam.eye.x)
        self.cam_eye_y.setValue(cam.eye.y)
        self.cam_eye_z.setValue(cam.eye.z)
        self.cam_look_x.setValue(cam.look_at.x)
        self.cam_look_y.setValue(cam.look_at.y)
        self.cam_look_z.setValue(cam.look_at.z)
        self.cam_up_x.setValue(cam.up.x)
        self.cam_up_y.setValue(cam.up.y)
        self.cam_up_z.setValue(cam.up.z)
        self.cam_fov.setValue(float(cam.fov))
        self.img_w.setValue(int(cam.img_width))
        self.img_h.setValue(int(cam.img_height))

        li = self.scene.light
        self.light_px.setValue(li.position.x)
        self.light_py.setValue(li.position.y)
        self.light_pz.setValue(li.position.z)
        self.light_lx.setValue(li.look_at.x)
        self.light_ly.setValue(li.look_at.y)
        self.light_lz.setValue(li.look_at.z)
        self.light_ux.setValue(li.up.x)
        self.light_uy.setValue(li.up.y)
        self.light_uz.setValue(li.up.z)
        self.light_w.setValue(float(li.width))
        self.light_h.setValue(float(li.height))
        self.light_int.setValue(float(li.intensity))
        self.light_r.setValue(_clamp01(li.color.r))
        self.light_g.setValue(_clamp01(li.color.g))
        self.light_b.setValue(_clamp01(li.color.b))

    def _apply_scene_edits(self):
        self.scene.name = self.scene_name.text().strip() or "Editor Scene"

        self.scene.background = Color3(self.bg_r.value(), self.bg_g.value(), self.bg_b.value())
        self.scene.ambient_light = Color3(self.amb_r.value(), self.amb_g.value(), self.amb_b.value())
        self.scene.max_depth = int(self.max_depth.value())

        cam = self.scene.camera
        cam.eye = Vec3(self.cam_eye_x.value(), self.cam_eye_y.value(), self.cam_eye_z.value())
        cam.look_at = Vec3(self.cam_look_x.value(), self.cam_look_y.value(), self.cam_look_z.value())
        cam.up = Vec3(self.cam_up_x.value(), self.cam_up_y.value(), self.cam_up_z.value())
        cam.fov = float(self.cam_fov.value())
        cam.img_width = int(self.img_w.value())
        cam.img_height = int(self.img_h.value())

        li = self.scene.light
        li.position = Vec3(self.light_px.value(), self.light_py.value(), self.light_pz.value())
        li.look_at = Vec3(self.light_lx.value(), self.light_ly.value(), self.light_lz.value())
        li.up = Vec3(self.light_ux.value(), self.light_uy.value(), self.light_uz.value())
        li.width = float(self.light_w.value())
        li.height = float(self.light_h.value())
        li.intensity = float(self.light_int.value())
        li.color = Color3(self.light_r.value(), self.light_g.value(), self.light_b.value())

    def _load_object_widgets(self, obj: ObjectSpec):
        self.obj_name.blockSignals(True)
        self.obj_kind.blockSignals(True)
        self.mat_kind.blockSignals(True)

        self.obj_name.setText(obj.name)
        self.obj_kind.setCurrentText(obj.kind)
        self._switch_params_page(obj.kind)

        if obj.kind == "ball":
            self.ball_radius.setValue(float(obj.params.get("radius", 1.0)))
        elif obj.kind == "cube":
            self.cube_size.setValue(float(obj.params.get("size", 1.0)))
        elif obj.kind == "cilinder":
            self.cyl_radius.setValue(float(obj.params.get("radius", 0.5)))
            self.cyl_height.setValue(float(obj.params.get("height", 2.0)))
        else:
            self.pl_px.setValue(float(obj.params.get("px", 0.0)))
            self.pl_py.setValue(float(obj.params.get("py", 0.0)))
            self.pl_pz.setValue(float(obj.params.get("pz", 0.0)))
            self.pl_nx.setValue(float(obj.params.get("nx", 0.0)))
            self.pl_ny.setValue(float(obj.params.get("ny", 0.0)))
            self.pl_nz.setValue(float(obj.params.get("nz", 1.0)))
            self.pl_fx.setValue(float(obj.params.get("fx", 1.0)))
            self.pl_fy.setValue(float(obj.params.get("fy", 0.0)))
            self.pl_fz.setValue(float(obj.params.get("fz", 0.0)))

        # transform (disable for plane)
        is_plane = obj.kind == "planeuv"
        self.tr_group.setEnabled(not is_plane)

        tr = obj.transform
        self.tr_tx.setValue(tr.translate.x)
        self.tr_ty.setValue(tr.translate.y)
        self.tr_tz.setValue(tr.translate.z)
        self.tr_sx.setValue(tr.scale.x)
        self.tr_sy.setValue(tr.scale.y)
        self.tr_sz.setValue(tr.scale.z)
        self.tr_rz.setValue(float(tr.rot_z_deg))

        self.mat_kind.setCurrentText(obj.material.kind)
        self._switch_material_page(obj.material.kind)
        if obj.material.kind == "matte":
            self.matte_dr.setValue(float(obj.material.params.get("dr", 0.7)))
            self.matte_dg.setValue(float(obj.material.params.get("dg", 0.2)))
            self.matte_db.setValue(float(obj.material.params.get("db", 0.2)))
        elif obj.material.kind == "checker":
            self.checker_square.setValue(float(obj.material.params.get("square_size", 1.0)))
        else:
            self.mirror_reflect.setValue(float(obj.material.params.get("reflection", 1.0)))

        self.obj_name.blockSignals(False)
        self.obj_kind.blockSignals(False)
        self.mat_kind.blockSignals(False)

    def _apply_obj_edits(self):
        if self._selected_index is None:
            return
        obj = self.scene.objects[self._selected_index]

        new_name = self.obj_name.text().strip() or obj.name
        # keep unique
        if new_name != obj.name:
            existing = {o.name for i, o in enumerate(self.scene.objects) if i != self._selected_index}
            if new_name in existing:
                self._log(f"Name '{new_name}' already exists; keeping '{obj.name}'.")
            else:
                obj.name = new_name

        obj.kind = self.obj_kind.currentText()

        if obj.kind == "ball":
            obj.params["radius"] = float(self.ball_radius.value())
        elif obj.kind == "cube":
            obj.params["size"] = float(self.cube_size.value())
        elif obj.kind == "cilinder":
            obj.params["radius"] = float(self.cyl_radius.value())
            obj.params["height"] = float(self.cyl_height.value())
        else:
            obj.params["px"] = float(self.pl_px.value())
            obj.params["py"] = float(self.pl_py.value())
            obj.params["pz"] = float(self.pl_pz.value())
            obj.params["nx"] = float(self.pl_nx.value())
            obj.params["ny"] = float(self.pl_ny.value())
            obj.params["nz"] = float(self.pl_nz.value())
            obj.params["fx"] = float(self.pl_fx.value())
            obj.params["fy"] = float(self.pl_fy.value())
            obj.params["fz"] = float(self.pl_fz.value())

        # transform
        if obj.kind != "planeuv":
            obj.transform.translate = Vec3(self.tr_tx.value(), self.tr_ty.value(), self.tr_tz.value())
            obj.transform.scale = Vec3(self.tr_sx.value(), self.tr_sy.value(), self.tr_sz.value())
            obj.transform.rot_z_deg = float(self.tr_rz.value())

        # material
        obj.material.kind = self.mat_kind.currentText()
        if obj.material.kind == "matte":
            obj.material.params = {
                "dr": float(self.matte_dr.value()),
                "dg": float(self.matte_dg.value()),
                "db": float(self.matte_db.value()),
            }
        elif obj.material.kind == "checker":
            obj.material.params = {"square_size": float(self.checker_square.value())}
        else:
            obj.material.params = {"reflection": float(self.mirror_reflect.value())}

        self._refresh_object_list()
        self.object_list.setCurrentRow(self._selected_index)

    def _obj_kind_changed(self, kind: str):
        self._switch_params_page(kind)
        # keep transform disabled for plane
        self.tr_group.setEnabled(kind != "planeuv")
        self._apply_obj_edits()

    def _switch_params_page(self, kind: str):
        idx = ["ball", "cube", "cilinder", "planeuv"].index(kind)
        self.params_stack.setCurrentIndex(idx)

    def _mat_kind_changed(self, kind: str):
        self._switch_material_page(kind)
        self._apply_obj_edits()

    def _switch_material_page(self, kind: str):
        idx = ["matte", "checker", "mirror"].index(kind)
        self.mat_stack.setCurrentIndex(idx)

    # ----- export/render -----

    def _browse_scene_path(self):
        path, _ = QtWidgets.QFileDialog.getSaveFileName(
            self,
            "Save scene file",
            self.out_scene_path.text(),
            "Python files (*.py)",
        )
        if path:
            self.out_scene_path.setText(path)

    def _export_scene_clicked(self):
        self._apply_scene_edits()
        self._apply_obj_edits()
        out_path = self.out_scene_path.text().strip() or "scene_editor_output.py"
        export_scene_py(self.scene, out_path)
        self._log(f"Exported scene to: {out_path}")

    def _render_clicked(self):
        self._export_scene_clicked()

        out_scene_path = self.out_scene_path.text().strip() or "scene_editor_output.py"
        module_name = os.path.splitext(os.path.basename(out_scene_path))[0]
        out_img = self.out_img_path.text().strip() or "preview.png"

        cmd = [
            sys.executable,
            "raster.py",
            "-s",
            module_name,
            "-n",
            str(int(self.samples.value())),
            "-j",
            str(int(self.jobs.value())),
            "-o",
            out_img,
        ]

        self._log("Running: " + " ".join(cmd))
        try:
            proc = subprocess.run(
                cmd,
                cwd=os.getcwd(),
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
            )
            if proc.stdout:
                self._log(proc.stdout.rstrip())
            if proc.returncode != 0:
                self._log(f"Render failed (exit={proc.returncode}).")
                return
        except Exception as e:
            self._log(f"Render error: {e}")
            return

        if os.path.exists(out_img):
            pix = QtGui.QPixmap(out_img)
            if not pix.isNull():
                self.preview.setPixmap(pix)
                self._log(f"Preview updated: {out_img}")
            else:
                self._log(f"Could not load image: {out_img}")
        else:
            self._log(f"Output image not found: {out_img}")

    def _log(self, msg: str):
        self.render_log.appendPlainText(msg)


def main():
    app = QtWidgets.QApplication(sys.argv)
    w = MainWindow()
    w.resize(1200, 800)
    w.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
